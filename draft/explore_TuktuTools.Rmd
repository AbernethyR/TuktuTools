---
title: "Analysis of Caribou Movements with the TuktuTools R Package"
author: "Ophélie Couriot and Eliezer Gurarie"
date: "5/5/2023"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{explore_TuktuTools}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, out.width="100%", dpi=600)
```

# Introduction

During this workshop, we will demonstrate the `TuktuTools` package, which has been developed for studying Tuktu (caribou) movement ecology and spatial patterns. 

To date, this package contains functions that prep and filter movement data:

- `process_moveNWT` - processes data from Movebank;
- `removeoutliers` - flags fixes considered as *outliers*;
- `prepData` - prepares and filters data to a specific period of time and/or a minimum number of fixes per day; 
- `scan_tracks` - visualizes individual paths through time

The package also contains functions that analyze spatial patterns, including:
- `getSpeed` - computes individual movement rates, displacements, speeds;
- `getDailyMean` - estimates individual mean daily location (i.e., the mean x and y coordinates of all the daily locations for a given individual);
- `getLoCoH` and `getKernelUD` - estimates ranging areas with Local Convex Hulls (LoCoH) or Kernel Utilization Distributions (KUD);
- `getPairwiseDistance` and `getPairwiseOverlap` - estimates daily pairwise distance or pairwise overlap between pairs of individuals;
- `estimateCalving` - estimates calving status (non-calving or calving, calving with survival or calving with calf death), calving timing, and calving location for given females, using movement rate; 
- `estimateMigration_stan` - estimates population-level migration timing using STAN

The package contains the following data:

- `caribou` - anonymized movement data for 4 individual Barren-ground caribou;
- `simulated_migrations` - simulated movement tracks for 18 individuals

# Installation

To install the current version of this package in R:

```{r, eval = FALSE}
install.packages("devtools")

devtools::install_github("ocouriot/TuktuTools", build_vignettes = TRUE)
```


# Chapter 1: Data and Vizualisation

## Data

The `TuktuTools` package contains real movement data from 4 caribou individuals, which have been anonymized.
The package also contains data of 18 simulated tracks of caribou, during the spring migration.

```{r, message = FALSE}
require(TuktuTools)
data(package = 'TuktuTools')
```


## Explore data

The `caribou` dataset contains real movement data for 4 caribou individuals. It contains the `ID` of the individuals, the `sex`, as well as the `Time` and `Lon`,`Lat` (in WGS 84, epsg: 4326) and `x`,`y` (UTM zone 10N, epsg: 32610) coordinates of their GPS locations. 

```{r}
data(caribou)
head(caribou)
```

### Number of individuals and sex

```{r}
unique(caribou$ID)
```

There are 4 individuals: Dancer, Prancer, Vixen and Comet.

Their sex:
```{r}
with(caribou, unique(data.frame(ID, sex)))
```

They are all females.

### What is the range and duration of their monitoring? 

What are the years each individual was monitored?

```{r}
with(caribou, unique(data.frame(ID, Year)))
```

One approach is to use plyr::ddply commands. This function allows you apply functions to different groups (subsets) of a data set. Here’s an example:
```{r}
caribou %>% ddply("ID", plyr::summarize, 
                 start= min(Time), end = max(Time)) %>%  # get the first and last locations time for each individual
  mutate(duration = difftime(end, start, units = "days")) # calculate duration
```


We can visualize the monitoring duration for each individual, on a plot, by extracting the start date and the end date of the monitoring for each individual.

```{r}
n.summary <- caribou %>% group_by(ID) %>% 
  summarize(start = min(Time), end = max(Time)) %>% # get the first and last locations time
  mutate(ID = factor(ID, levels = as.character(ID)))
  
ggplot(n.summary, aes(y = ID, xmin = start, xmax = end)) + 
    geom_linerange() 
```

When there are multiple individuals (sometimes hundreds), It may make more sense to sort the individuals not alphabetically, but by the time of capture. Here’s an approach:

```{r}
n.summary <- caribou %>% group_by(ID) %>% 
  summarize(start = min(Time), end = max(Time)) %>% 
  arrange(start) %>% # arrange chronologically instead of by ID
  mutate(ID = factor(ID, levels = as.character(ID)))
  
ggplot(n.summary, aes(y = ID, xmin = start, xmax = end)) + 
    geom_linerange() 
```

On those figures each line represents the duration of the monitoring (x axis) for a given individual (y axis). 

### What is the fix rate?

The fix rate, or the time lag between successive locations, can be extracted by using the difftime() function on the Time column. Again, this function needs to be applied to each individual separately. Here, we are subsetting the data set per ID, and applying a function which is adding a column difftime to each subset. Note that since the vector of time difference is smaller than the vector of time, we add a missing value at the beginning of each vector, for each value to represent the difference in time to the previous location.

```{r}
caribou <- caribou %>% ddply("ID", mutate, 
        dtime = c(NA, difftime(Time[-1], Time[-length(Time)], units = "hours"))) # calculate time between successive locations
head(caribou)
```

What are the statistics (min, max, mean, median, …) of this fix rate?

```{r}
caribou$dtime %>% summary
```
On average, the fix rate is ~4 hours (median is 8 hours), the shortest fix is 1 minute and the longest is 160 hours, or ~ 7 days.

Which animal is it and when did it occur?

```{r}
# which row corresponds to the big fix rate
which(caribou$dtime > 159 & is.na(caribou$dtime) == FALSE)

# look at the rows around the one with a big fix rate
caribou[13426:13430,]
```

Vixen has missing data between April 11, 2009 and April 18, 2009. 


## Prepare and filter data

Now that we know what the data look like, we can prepare and filter them depending on what we are examining.
Later in this workshop, we will identify calving timing and calving location for each female. Barren-ground caribou calve between mid-May to mid-June. Studies examining calving dates considered data between May 19 and July 7 (@cameronMovementbasedMethodsInfer2018; @couriotContinentalSynchronyLocal2023).
So let's filter and prepare the data during this period for each individual.

The `prepData` function, from the `TuktuTools` package, allows to filter data for a defined period, using a start date and an end date, irrespective of the year. This function also allows setting an average minimum number of fixes (relocations) per day, which exclude tracks for individuals having fewer daily fixes than this threshold. Finally, it allows defining a maximum number of successive days missing data. The two last parameters are optional. 
This function returns a data frame filtered as desired, and indicates the number of individual-year that have been excluded.

```{r}
caribou_prepped <- prepData(caribou, start = "05-19", end = "07-07")
```
2 individual-year have been excluded. We can compare the individual-year with our original dataset, to know which individuals have been lost.

```{r}
setdiff(unique((caribou %>% mutate(ID_year = paste(ID, Year, sep = ":")))$ID_year),
        unique((caribou_prepped %>% mutate(ID_year = paste(ID, Year, sep = ":")))$ID_year))
```
```{r, echo = FALSE}
n.summary <- caribou %>% group_by(ID) %>% 
  summarize(start = min(Time), end = max(Time)) %>% 
  arrange(start) %>% # arrange chronologically instead of by ID
  mutate(ID = factor(ID, levels = as.character(ID)))
  
ggplot(n.summary, aes(y = ID, xmin = start, xmax = end)) + 
    geom_linerange() 
```

Looking back at this figure, we see it is because those two individuals were not monitored during the calving period those years.

## Visualizing data

`TuktuTools` contains a function to visualize animal tracks: `scan_tracks`. It is helpful to see individuals' trajectories, as well as examine the variation of their x and y locations through time.
Note: to use this function, X,Y columns must be capitalized.

### Using `scan_track`

```{r}
scan_tracks(caribou_prepped %>% mutate(X=x, Y=y))
```

As individuals are not monitored the same years (and some of them have several years of monitoring), it is difficult to examine the variation of x and y coordinates through time. We can thus apply this function per individual and per year:

```{r}
caribou_prepped %>% mutate(X=x, Y=y) %>% ddply(c("ID", "Year"), scan_tracks, legend = TRUE)
```

### Visualization on a map

We can also visualize the trajectories on a map, using the package `basemap`, which allows to download a base map as a raster.
Note that it takes coordinates in WGS84 (crs = 4326), and return a map with a different crs (crs = 3857).

```{r}
# transform the dataset in a simple feature object (projected object)
caribou_sf <- caribou_prepped %>% st_as_sf(coords=c("Lon", "Lat"), crs = 4326)

# download the map using the basemaps::basemap_raster
bbox <- st_bbox(caribou_sf) + c(-1,-1,1,1)
map <- basemaps::basemap_raster(ext = bbox, map_service = "osm", map_type = "topographic", map_res = 2)

# create lines for each individual dand year
# transform in crs: 3857 (same as the map for plotting)
lines <- caribou_sf %>% 
  group_by(ID, Year) %>% arrange(Time) %>%
  summarize(do_union = FALSE) %>%
  st_cast("LINESTRING") %>% st_transform(3857)
  
# add colors using viridis
library(viridis)
cols <- data.frame(ID = unique(caribou_sf$ID),
                   cols = viridis(length(unique(caribou_sf$ID))))
lines <- lines %>% merge(cols, by = "ID")

# Draw the map and add the individuals tracks with legend
raster::plotRGB(map, asp = 1, alpha = 100)
plot(st_geometry(lines), add = TRUE, col = alpha(lines$cols, alpha = .6), lwd = 2)
legend("right", legend = cols$ID, 
     col = cols$cols,
     lwd = 2,  ncol=1)
```
### Using Mapview

The `mapview` package is really handy, as it creates interactive map, using simple feature objects.

```{r}
mapview::mapview(lines, zcol = "ID")
```

We can zoom in and out on the map, as well as click on the lines to have its information.

# Chapter 2: Basic analysis using TuktuTools

The `TuktuTools` packages offers a range of functions allowing to easily summarize data and estimate movement rate and range distributions.

## Get the daily mean location

The `getDailyMean` function is a function which takes any large movement dataset and return the daily mean locations for each individual for each day for each year of observations.

Let's calculate the daily mean locations for individuals during the calving period.

```{r}
caribou_daily_mean <- getDailyMean(caribou_prepped)
head(caribou_daily_mean)
```
This function becomes handy when we are dealing with very large dataset, to homogenize data, by having one location per day for each individual, and do further analyses not requiring a fine fix rate.


## Get the daily movement rate

The package contains a function which is calculating the movement rate between successive locations for each individual: `getSpeed`.

Calculating the movement rate between successive daily locations. Note that this function calculate movement rate for each individual separately, but if individuals are monitored several years with a break in between (as in this case, since we considered only the calving period), it is essential to apply this function to each individual and year separately!

```{r}
daily_mr <- caribou_daily_mean %>% 
  ddply(c("ID", "Year"), getSpeed)
head(daily_mr)
```

We can visualize the movement rate of each individual through time. To have all the individuals on the same figure, we add a column `doy` (i.e, day of year). We also need to create a column for each ID-Year, as some individuals have been monitored several years.

```{r}
daily_mr <- daily_mr %>% mutate(doy = yday(Time), ID_Year = as.factor(paste(ID, Year, sep = "_")))
ggplot(data = daily_mr, aes(x = doy, y = speed, group = ID_Year, colour = ID_Year)) + geom_line()
```

## Get Kernel UD

In the `TuktuTools` package, we added a function that allows to easily compute kernel utilization distributions, in one line of code: `getKernelUD`. This function uses the function `kernelUD` from the `adehabitatHR` package, and thus has the same parameters found in the `kernelUD` function.

```{r}
individuals_kernel <- caribou_daily_mean %>% st_as_sf(coords=c("x", "y"), crs = 32610) %>%
  ddply(c("ID","Year"), getKernelUD, extent = 10) %>% st_as_sf(crs = 32610)
head(individuals_kernel)

# visualize
mapview::mapview(individuals_kernel, zcol = "ID")
```

## Get LoCoH

We also added the `getLoCoH` function, which allows to compute Local Convex Hull (LoCoH), which is known to perform better than parametric kernel methods, in the context of estimating the size of HRs and delineating geological and ecological features in home ranges.
The LoCoH method is both a generalization of the minimum convex polygon (MCP) method and essentially a non-parametric kernel method. LoCoH applies the MCP construction to a subset of data localized in space, and the local convex polygon (i.e. local hull) is constructed using a specific number of nearest neighbors (nn) of each data point, thereby producing a set of nonparametric kernels whose union is the UD.
One adavntage of using LoCoH is that this method allows to consider avoided areas (or holes) in ranges.


```{r}
individuals_locoh <- caribou_daily_mean %>% st_as_sf(coords=c("x", "y"), crs = 32610) %>%
  ddply(c("ID","Year"), getLoCoH) %>% st_as_sf(crs = 32610)
head(individuals_locoh)

# visualize
mapview::mapview(individuals_locoh, zcol = "ID")
```


The default number of nearest neighbors in the `getLoCoH` function as been set to 10. However, it is  worth noting that the resulting area is sensitive to the number of nearest neighbors chosen when computing the Local Convex Hulls (LoCoH). We recommend trying different numbers of nearest neighbors to compute ranges.

Let's try here with a bigger number of nearest neighbors:
```{r}
individuals_locoh2 <- caribou_daily_mean %>% st_as_sf(coords=c("x", "y"), crs = 32610) %>%
  ddply(c("ID","Year"), getLoCoH, nn = 30) %>% st_as_sf(crs = 32610)
head(individuals_locoh2)

#  visualize
mapview::mapview(individuals_locoh2, zcol = "ID")
```

We can see that the more nearest neighbors, the less sensitive to avoided areas the method is.

# Chapter 3: Estimating parturition time and location

To estimate parturition time and location, we refined the “individual-based method” (IBM) developed by DeMars et al (2013) to infer calving status. The method is detailed in the `estimating_parturition`vignette of the `TuktuTools` package.

